# -*- coding: utf-8 -*-
"""Paint.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aum_9ylW_0Zc60_IysNBsLMfbzkRAK7o
"""

class Canvas:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        # Empty canvas is a matrix with element being the "space" character
        self.data = [[' '] * width for i in range(height)]

    def set_pixel(self, row, col, char='*'):
        self.data[int(row)][int(col)] = char

    def get_pixel(self, row, col):
        return self.data[row][col]

    def clear_canvas(self):
        self.data = [[' '] * self.width for i in range(self.height)]

    def v_line(self, x, y, w, **kargs):
        x=int(x)
        z=int(x+w)
        for i in range(x,z):
            self.set_pixel(i,y, **kargs)

    def h_line(self, x, y, h, **kargs):
        y = int(y)
        z = int(y+h)
        for i in range(y,z):
            self.set_pixel(x,i, **kargs)

    def line(self, x1, y1, x2, y2, **kargs):
        slope = (y2-y1) / (x2-x1)
        for y in range(int(y1),int(y2)):
            x= int(slope * y)
            self.set_pixel(x,y, **kargs)

    def display(self):
        print("\n".join(["".join(row) for row in self.data]))

from numpy import linspace
import math
class shapes:
    def __init__(self,point=(0,0)):
        self.__point=point

    def area(self):
        raise NotImplementedError

    def info(self):
        raise NotImplementedError

    def points(self,n_points):
        raise NotImplementedError

    def inside(self,point):
        raise NotImplementedError

    def overlap(self,shape2):
        outline=self.points(16)
        for coord in outline:
            if shape2.inside(coord) == True:
                return True
        return False

#rectangle subclass
class rectangle(shapes):
    def __init__(self,length,width,point=(0,0)):
        self._length=abs(float(length))
        self._width=abs(float(width))
        self._corner=point
        if self._length == 0 or self._width == 0:
            raise ValueError

    def info(self):
        print(f"""Length: {self._length}\
        Width: {self._width}\
        Corner: {self._corner}""")

    def area(self):
        super().info()
        return self._width*self._length

    def perimeter(self):
        return 2*(self._width+self._length)

    def points(self,n_points):
        l_points=set()
        n_points = int(n_points)
        if n_points <= 0:
            return []
        elif n_points > 16:
            n_points = 16
        x,y=self._corner
        x2= x + self._length
        y2= y + self._width

        l_points.update([self._corner,(x2,y),(x,y2),(x2,y2)])

        for x_coord in linspace(x,x2,num=n_points//4+1):
            l_points.add((x_coord,y))
            l_points.add((x_coord,y2))

        for y_coord in linspace(x,x2,num=n_points//4+1):
            l_points.add((x,y_coord))
            l_points.add((x2,y_coord))

        l_points = list(l_points)
        return l_points[:n_points]

    def inside(self,point=(0,0)):
        if (self._corner[0] <= point[0] <= (self._corner[0]+self._length)) and \
        (self._corner[1] <= point[1] <= (self._corner[1]+self._width)):
            return True
        else:
            return False

    def paint(self,canvas,display=True):
      x,y=self._corner
      x2 = int(x + self._length)
      y2 = int(y + self._width)

      points = self.points(16)
      for coord in points:
        canvas.set_pixel(int(coord[0]),int(coord[1]))
      if display == True:
        canvas.display()
    def __repr__(self):
        return f"rectangle({self._length}, {self._width}, {self._corner})"


#circle subclass
class circle(shapes):
    def __init__(self,radius,center=(0,0)):
        self._radius=abs(float(radius))
        self._center=center
        if self._radius == 0:
            raise ValueError

    def info(self):
        print(f"""Radius: {self._radius}\
        Center: {self._center}""")

    def area(self):
        return (3.14*(self._radius**2))

    def circumference(self):
        return (3.14*(2*self._radius))

    def points(self,n_points):
        l_points=list()
        n_points = int(n_points)
        if n_points <= 0:
            return []
        elif n_points > 16:
            n_points = 16

        x,y=self._center

        l_points += [(x+self._radius,y), #0º
                    (x,y+self._radius), #90º
                    (x-self._radius,y), #180º
                    (x,y-self._radius), #270º
                    ((x+self._radius)*((3**0.5)/2),(y+self._radius)*0.5), #30º
                    ((x+self._radius)*((2**0.5)/2),(y+self._radius)*((2**0.5)/2)), #45º
                    ((x+self._radius)*0.5,(y+self._radius)*((3**0.5)/2)), #60º
                    ((x+self._radius)*-0.5,(y+self._radius)*((3**0.5)/2)), #120º
                    ((x+self._radius)*-1*((2**0.5)/2),(y+self._radius)*((2**0.5)/2)), #135º
                    ((x+self._radius)*(-1*(3**0.5)/2),(y+self._radius)*0.5), #150º
                    ((x+self._radius)*(-1*(3**0.5)/2),(y+self._radius)*-0.5), #210º
                    ((x+self._radius)*(-1*(2**0.5)/2),(y+self._radius)*(-1*(2**0.5)/2)), #225º
                    ((x+self._radius)*-0.5,(y+self._radius)*(-1*(3**0.5)/2)), #240º
                    ((x+self._radius)*0.5,(y+self._radius)*(-1*(3**0.5)/2)), #300º
                    ((x+self._radius)*((2**0.5)/2),(y+self._radius)*(-1*(2**0.5)/2)), #315º
                    ((x+self._radius)*((3**0.5)/2),(y+self._radius)*-0.5)] #330º
        return l_points[:n_points]

    def inside(self,point=(0,0)):
        dist = ((point[0]-self._center[0])**2 + (point[1]-self._center[1])**2)**0.5 #distance from center
        return dist<=self._radius

    def paint(self,canvas,display=True):
      outline=list()
      x, y = self._center
      r = self._radius

      for angle in range(0, 360, int(360 / 16)):
        rad = math.radians(angle)
        x_point = round(x + r * math.cos(rad))
        y_point = round(y + r * math.sin(rad))
        outline.append((x_point, y_point))
      for point in outline:
        x,y=point
        canvas.set_pixel(int(x),int(y))
      if display == True:
        print(len(outline),outline)
        canvas.display()

    def __repr__(self):
        return f"circle({self._radius}, {self._center})"


#triangle sublcass
class triangle(shapes):
    def __init__(self,side1,side2,side3,point=(0,0)):
        self._side1=abs(float(side1))
        self._side2=abs(float(side2))
        self._side3=abs(float(side3))
        self._point=point
        if not (self._side1+self._side2>self._side3 and self._side1+self._side3>self._side1,self._side2+self._side3>self._side1):
            raise ValueError
        if self._side1 == 0 or self._side2 == 0 or self._side3 == 0:
            raise ValueError

    def info(self):
        print(f"""Side 1: {self._side1}\
        Side 2: {self._side2}\
        Side 3: {self._side3}\
        Corner: {self._point}""")

    def perimeter(self):
        return self._side1+self._side2+self._side3

    def area(self):
        s= self.perimeter()/2
        return (s*(s - self._side1)*(s - self._side2)*(s - self._side3))**0.5

    def points(self,n_points=16):
        l_points=set()
        n_points = int(n_points)
        if n_points <= 0:
            return []
        elif n_points > 16:
            n_points = 16

        x,y=self._point
        x2 = x+self._side1 #point: (x2,y)

        x3 = x + (self._side2**2 - self._side3**2 + self._side1**2) / (2 * self._side1)
        y3 = y + (self._side3**2 - (x3 - x)**2) ** 0.5

        l_points.update([(x,y),(x2,y),(x3,y3)])

        for x_coord in linspace(x,x2,num=6):
            #base of triangle
            l_points.add((x_coord,y))

        def func(x, xA, yA, xB, yB):
          if xA == xB:
              return yA
          m = (yB - yA) / (xB - xA)
          return m * (x - xA) + yA

        #left side
        for x_coord in linspace(x, x3, 6):
          l_points.add((x_coord, func(x_coord, x, y, x3, y3)))

        #right side
        for x_coord in linspace(x2, x3, 6):
          l_points.add((x_coord, func(x_coord, x2, y, x3, y3)))
        l_points=list(l_points)
        return l_points[:n_points]

    def inside(self,point=(0,0)):
        xx,xy = point
        x1,y = self._point
        x2 = x1 + self._side1
        x3 = x1 + (self._side2**2 - self._side3**2 + self._side1**2)/(2*self._side1)
        y3 = y + ((self._side3**2-((self._side2**2-self._side3**2+self._side1**2)/(2*self._side1))**2)**0.5)

        def func2(coord,i=False): #left
            m=(y-y3)/(x1-x3)
            b=y-m*x1
            if i == False:
                return m*coord+b
            else:
                return (coord-b)/m
        def func3(coord,i=False): #right
            m=(y-y3)/(x2-x3)
            b=y-m*x2
            if i == False:
                return m*coord+b
            else:
                return (coord-b)/m

        return y<=xy<=y3 and (func2(xy,i=True) <= xx <= func3(xy,i=True))

    def paint(self,canvas,display=True):
      outline = self.points()
      for point in outline:
        x,y = int(point[0]),int(point[1])
        canvas.set_pixel(x,y)

      if display == True:
        canvas.display()
        
    def __repr__(self):
        return f"triangle({self._side1}, {self._side2}, {self._side3}, {self._point})"


class CompoundShape(shapes):
  def __init__(self):
    self.shapes = list()

  def add_shape(self,shape):
    self.shapes.append(shape)

  def paint(self,canvas):
    for shape in self.shapes:
      shape.paint(canvas,False)
    canvas.display()

